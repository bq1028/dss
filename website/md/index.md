DSS (_Deterministic StyleSheets_) is a component-oriented CSS authoring system that compiles to high-performance _Atomic CSS_-based stylesheets. Thanks to the DSS compiler and a simple `classNames` helper, DSS styles are resolved in deterministic way that respects the application order.

DSS is similar to CSS Modules and it is language agnostic. Styles are authored in static `.css` files, compiled down to atomic classes for smaller bundle size and then consumed in any language (Ruby, PHP, Python etc) that implements the super simple `classNames` helper.

Given two class names that set the `color` to `red` and `green`:

```css
.foo {
  color: red;
}
.bar {
  color: green;
}
```

when applied to an element one class wins over the other depending on the order in which the classes are applied:

```html
<!-- green -->
<div class="foo bar">hello</div>

<!-- red -->
<div class="bar foo">hello</div>
```

Such a feature makes it possible to tell with **confidence** which rules apply or overrule others at any given point in time.

This website is styled with DSS and its source code is available on [GitHub](https://github.com/giuseppeg/dss/tree/master/website). We also have a handful of [examples](https://github.com/giuseppeg/dss/tree/master/examples).

## Features

* ‚ö°Ô∏è Automatic compilation to Atomic CSS classes and high-performance stylesheets
* üÜé Deterministic styles resolution: styles are always resolved in application order
* üåé Framework and language agnostic
* ü§ù Preprocessors friendly
* üíª Standalone CLI and support for Webpack 3 and 4 with automatic vendor prefixing
* ‚úÇÔ∏è CSS the Best Parts

## Atomic CSS and smaller bundles

The DSS compiler converts every CSS declaration to an atomic CSS class and returns a JSON object that contains mappings to the source rules.

```css
// index.css

.foo {
  display: flex;
  flex-direction: column;
  color: red;
}

.bar {
  display: flex;
  color: green;
}
```

Is compiled to:

```JSON
{
 "foo": [
    "dss_14e3233-fkmc3a",
    "dss_1uacqdt-m23pbg",
    "dss_rfc3hq-169mlyl"
  ],
  "bar": [
    "dss_14e3233-fkmc3a",
    "dss_rfc3hq-5rjgso"
  ]
}
```


When compiling multiple files, the JSON for each file should be written to disk and at the end of the compilation the atomic CSS generated by DSS is available via a `dss.flush()` call. The string returned by `flush` contains the entire app CSS.

```css
/* dss.flush() */

.dss_14e3233-fkmc3a{display:flex}
.dss_1uacqdt-m23pbg{flex-direction:column}
.dss_rfc3hq-169mlyl{color:red}
.dss_rfc3hq-5rjgso{color:green}
```

Since we are using atomic classes, declarations are deduped and the final bundle size should be small. With atomic CSS classes the file size growth is logarithmic since DSS produces rules only for new declarations. This strategy also makes critical CSS extraction unnecessary.

## Deterministic styles resolution and the classNames helper

DSS is about providing confidence when authoring CSS. This is done by resolving styles (selectors) in a deterministic way based on the application order of each class name. We think that it is very important to get a predictable result when applying two classes to an element.

DSS converts declarations to atomic CSS classes. This is done by hashing each property and value and building a class name like the following:

```
dss_<hash(property)>-<hash(value)>
```

For example `color: red` is always hashed to:

```
dss_rfc3hq-169mlyl
```

and `color: green` to:


```
dss_rfc3hq-5rjgso
```

The first part of these class names is the same: `dss_rfc3hq-` and this is information is used to resolve styles.

Given two CSS rules:

```css
.foo {
  color: red;
}

.bar {
  color: green;
}
```

DSS compiles them to the following class names:

```JSON
{
 "foo": [
    "dss_rfc3hq-169mlyl"
  ],
  "bar": [
    "dss_rfc3hq-5rjgso"
  ]
}
```

Once we have this information we can write a simple `classNames` helper that accepts a comma separated list of class references (`foo` and `bar` in the example) and merges them right to left:

```js
className(styles.foo, styles.bar)

// dss_rfc3hq-5rjgso

className(styles.bar, styles.foo)

// dss_rfc3hq-169mlyl
```

This is similar to how `Object.assign` works in JavaScript, except that we are merging lists of atomic CSS classes.

## CSS: the Best Parts

DSS supports a subset of CSS that makes it possible to compile down to atomic CSS classes.

Generally rules match single class selectors but there are some exception where a higher specificity is actually necessary, this is the case for states and at rules which are supported as well.

Below is a comprehensive list of features:

### Supported

* Class selectors: `.foo`
* CSS states: `:hover`, `:active`, `:focus`, `:visited`, `:focus-within`, `:checked`, `:required`, `[disabled]`
* At-rules like `@media` and `@supports`
* State-combinator-selector like `:hover > .foo` or `:focus + .bar`

### Not supported

* Element, id, universal and attribute selectors
* Descendants selectors `.foo .bar`
* Class-combinator-class selectors `.foo > .bar`
* Pseudo elements like `:after` and `:before` since regular elements can be used instead

